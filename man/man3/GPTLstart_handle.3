.\" $Id: GPTLstart_handle.3,v 1.1 2011-03-28 20:55:19 rosinski Exp $
.TH GPTLstart_handle 3 "January, 2011" "GPTL"

.SH NAME
GPTLstart_handle \- Start a timer
.TP
GPTLstop_handle \- Stop a timer

.SH SYNOPSIS
.B C Interface:
.nf
int GPTLstart_handle (const char *name, void **handle);
int GPTLstop_handle (const char *name, void **handle);
.fi

.B Fortran Interface:
.nf
integer gptlstart_handle (character(len=*) name, integer*8 handle)
integer gptlstop_handle (character(len=*) name, integer*8 handle)
.fi

.SH DESCRIPTION
.B GPTLstart_handle()
starts a timer defined by
.I name. 
.B GPTLstop_handle()
stops a timer defined by
.I name.
The second argument, 
.I handle
, is used internally by GPTL to store the address of the timer defined by
.I name.
The advantage of using the _handle
versions of these start and stop functions (over GPTLstart and GPTLstop) is
speed. It saves a non-trivial amount of overhead for the library to know the
address of the timer, without having to first generate the hash value and
then check for collisions.

.SH ARGUMENTS
.I name
-- name of timer to start/stop. Only the first 63 characters are
significant. This limit can be modified in the GPTL library code by changing
the value of MAX_CHARS in private.h.

.I handle
-- storage used internally by GPTL for fast access to the timer defined by
.I name.
Internally it is used as a pointer, so in Fortran it is required that the
size be at least 8 bytes. The user must never modify its contents, except on
the initial call when a zero input value is a flag which tells GPTL to
overwrite its contents with the address of the timer for later use. When
called from within a threaded region, each thread must have a unique copy of
the
.I handle
variable, since GPTL maintains separate storage for timers which are invoked
from within threaded regions. Honestly, it is probably not worth the bother
of maintaining thread-specific handles when timing threaded regions. Just use
.B GPTLstart()
and
.B GPTLstop()
for these situations. These can be freely mixed with the _handle versions of
the functions as well. In other words, you can call
.B GPTLstart_handle()
in a single-threaded portion of the code, and then
.B GPTLstart()
in a multi-threaded portion, and GPTL will properly recognize that both
regions are the same for the master thread.

.SH RESTRICTIONS
.B GPTLinitialize()
must have been called. For 
.B GPTLstop_handle()
, a previous call to
.B GPTLstart_handle()
with the same
.I name
must have been made.

.SH RETURN VALUE
On success, these functions return 0.
On error, a negative error code is returned and a descriptive message
printed. 

.SH EXAMPLES
A complete sequence of GPTL library calls within a program should look
something like the following:
.nf         
.if t .ft CW

(void) GPTLsetoption (GPTLcpu, 1);           /* enable cpu timings */
(void) GPTLsetoption (GPTLwall, 0);          /* disable wallclock timings */
(void) GPTLsetoption (PAPI_TOT_CYC, 1);      /* enable counting of total cycles */
...
(void) GPTLinitialize();                     /* initialize the GPTL library */
(void) GPTLstart_handle ("total", handle1);  /* start a timer */
...
(void) GPTLstart_handle ("do_work", handle2);/* start another timer */

do_work();                                   /* do some work */

(void) GPTLstop_handle ("do_work", handle2); /* stop a timer */
(void) GPTLstop_handle ("total", handle1);   /* stop a timer */
...
(void) GPTLpr (mympitaskid);                 /* print the results to timing.<mympitaskid> */

.if t .ft P
.fi

.SH SEE ALSO
.BR GPTLstart "(3)"
.BR GPTLstop "(3)"
.BR GPTLpr "(3)"
.BR GPTLpr_file "(3)"
