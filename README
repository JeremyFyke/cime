GPTL is a general-purpose timing library. By itself it can gather wallclock
and cpu timing statistics for a code instrumented with an aribtrary sequence
of calls to the pair of routines "GPTLstart" and "GPTLstop" (more details
below). It is thread-safe, presuming either OpenMP or pthreads is
available. If the Fortran interface is built, entry point names and the API
are exactly the same as in C, except that Fortran is case-insensitive.

GPTL also provides hooks into the hardware counters library PAPI
(http://icl.cs.utk.edu/papi/index.html). If this option is enabled, the same
"GPTLstart" and "GPTLstop" calls can be used to provide various low-level
hardware counter info, such as total cycles, floating point ops, cache
misses, and various other performance information depending on the target
architecture. PAPI must already be installed in order to enable this option.


Building GPTL
-------------

After untarring the distribution and then doing "cd gptl", construct a
macros.make file by editing one of the templates provided (currenty there's
macros.make.linux, and macros.make.sicortex) that is closest to the machine
you're building the library on. Step-by-step instructions for setting each
configuration option are embedded in that file. If unsure of some settings,
you can run "./suggestions". This is an autoconf "configure" script which has
been modified to just print suggestions, rather than creating any output
files. After creating macros.make:

% make all
% make install

In addition to building the library, the "make all" step will build test
codes in subdirectories ctests/ and (if applicable) ftests/. Currently
there's not an automated testing procedure. To test the library and see how
it works, you'll need to "cd" into ctests/ or ftests/ and run the desired
test executables individually.


Using GPTL
----------

Code instrumentation to utilize GPTL involves an arbitrary number of calls to
GPTLsetoption(), then a single call to GPTLinitialize(), then an arbitrary
sequence of calls to GPTLstart() and GPTLstop(), and finally a call to
GPTLpr() or GPTLpr_file().  See the man pages for details of arguments to
these functions.  The man pages for GPTLstart and GPTLstop give an example
complete sequence of GPTL calls to instrument a code.  Also, various test
codes are built in the tests/ subdirectory of this distribution.

The purpose of GPTLsetoption is to enable or disable various library options.
For example, the PAPI counter for total cycles is also desired, then a call
of the form:

GPTLsetoption (PAPI_TOT_CYC, 1)

is required.  The list of available GPTL options is contained in gptl.h, and
the list of possible PAPI options is contained in the file papiStdEventDefs.h 
included with the PAPI distribution.

GPTLinitialize () initializes the GPTL library for subsequent calls to GPTLstart
and GPTLstop.  This is necessary for threading, and to initialize the PAPI
library in case support for it was requested in macros.make.

There can be an arbitrary number of start/stop pairs before GPTLpr() or
GPTLpr_file() is called to print the results.  And an arbitrary amount of
nesting of timers is also allowed.  The printed results will be indented to
indicate the level of nesting.

GPTLpr() prints the results to a file named timing.<number>, where <number>
is an input argument to GPTLpr. For MPI jobs, it is most convenient to use
the MPI rank. The entry point GPTLpr_file takes a single argument which is
the output file to write to.

GPTLfinalize() can be called to clean up the GPTL environment.  All space
malloc'ed by the GPTL library will be freed by this call.
